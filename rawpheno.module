<?php

/**
 * @file
 * The main functionality for this module.
 * Credits to:
 *   http://jamesdavidson.io/blog/how-create-multi-step-form-drupal-7
 *   https://github.com/nuovo/spreadsheet-reader
 *   https://github.com/SystemDevil/PHP_XLSXWriter_plus
 *   http://www.d3js.org
 *   https://laceysanderson.github.io/2016/07/23/Drupal-progress-bar.html
 */

// Include function to manage column headers.
module_load_include('inc', 'rawpheno', 'include/rawpheno.function.measurements');

// Include functions required in processing spreadsheet file.
module_load_include('inc', 'rawpheno', 'include/rawpheno.upload.excel');
module_load_include('inc', 'rawpheno', 'include/rawpheno.validation');
module_load_include('inc', 'rawpheno', 'include/rawpheno.upload.form');

/**
 * Implements hook_menu().
 */
function rawpheno_menu() {
  // The following menu items will default in Navigation menu block.
  // RAW DATA
  //  - DOWNLOAD DATA
  //  - INSTRUCTIONS
  //  - UPLOAD DATA

  // RAW DATA PAGE
  // A summary page of the raw data currently available.
  $items['phenotypes/raw'] = array(
    'title' => 'Raw Data',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('rawpheno_rawdata'),
    'access arguments' => array('access rawpheno'),
    'file' => 'include/rawpheno.rawdata.form.inc',
    'type' => MENU_NORMAL_ITEM,
  );
    // Menu callback which generates the summary data in JSON,
    // required by the heat map in rawdata page.
    $items['rawdata'] = array(
      'page callback' => 'rawpheno_rawdata_summary_json',
      'access callback' => true,
      'delivery callback' => 'drupal_json_output',
      'type' => MENU_CALLBACK,
    );

    // Menu callback which returns summary data for a trait (for histogram).
    $items['rawdata_trait'] = array(
      'page callback' => 'rawpheno_rawdata_trait_json',
      'access callback' => true,
      'delivery callback' => 'drupal_json_output',
      'type' => MENU_CALLBACK,
    );

    // Menu callback that returns year and location given a trait use to populate select boxes
    // to categorize barchart in rawdata page.
    $items['rawdata_trait_category'] = array(
      'page callback' => 'rawpheno_rawdata_trait_category_json',
      'access callback' => true,
      'delivery callback' => 'drupal_json_output',
      'type' => MENU_CALLBACK,
    );

  // INSTRUCTIONS PAGE
  // A page containing standard phenotyping procedure and
  // providing data collection spreadsheet.
  $items['phenotypes/raw/instructions'] = array(
    'title' => 'Instructions',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('rawpheno_instructions'),
    'access arguments' => array('access rawpheno'),
    'file' => 'include/rawpheno.instructions.form.inc',
    'type' => MENU_NORMAL_ITEM,
    'weight' => 0,
  );
    // Menu callback which generates a project specific data collection spreadsheet.
    $items['phenotypes/raw/instructions/%'] = array(
      'title' => 'Instructions',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('rawpheno_instructions', 3),
      'access arguments' => array('access rawpheno'),
      'file' => 'include/rawpheno.instructions.form.inc',
      'type' => MENU_CALLBACK,
    );
    // Menu callback which generates a list of headers in JSON,
    // used to autocomplete a search field and process search action
    // in instructions page.
    $items['phenotypes/raw/instructions/autocomplete/%'] = array(
      'page callback' => 'rawpheno_instructions_autocomplete_search',
      'page arguments' => array(4),
      'access arguments' => array('access rawpheno'),
      'type' => MENU_CALLBACK,
    );

    $items['phenotypes/raw/instructions/spreadsheet/%'] = array(
      'page callback' => 'rawpheno_instructions_create_spreadsheet',
      'page arguments' => array(4),
      'access arguments' => array('access rawpheno'),
      'file' => 'include/rawpheno.instructions.form.inc',
      'type' => MENU_CALLBACK,
    );

  // DOWNLOADS PAGE
  // A page providing export data options.
  // NOTE: Page below uses as different access arguments than
  //       the rest of the pages. Not everyone can download.
  $items['phenotypes/raw/download'] = array(
    'title' => 'Download Data',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('rawpheno_download'),
    'access arguments' => array('download rawpheno'),
    'file' => 'include/rawpheno.download.form.inc',
    'type' => MENU_NORMAL_ITEM,
    'weight' => 6,
  );

  $items['phenotypes/raw/csv'] = array(
    'title' => 'Download Raw Phenotypic Data: CSV',
    'page callback' => 'trpdownload_download_page',
    'page arguments' => array('rawpheno_csv'),
    'access arguments' => array('download rawpheno'),
    'type' => MENU_CALLBACK,
  );

  // DRAG AND DROP UPLOAD PAGE
  // A page for uploading and validating data collection spreadsheet.
  $items['phenotypes/raw/upload'] = array(
    'title' => 'Upload Data',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('rawpheno_upload_form_master'),
    'access arguments' => array('access rawpheno'),
	  'file' => 'include/rawpheno.upload.form.inc',
    'type' => MENU_NORMAL_ITEM,
    'weight' => 3,
  );
    // This callback will generate a job progress and status information
    // in JSON format to be used by the progress bar in the last stage of the upload process.
    $items['phenotypes/raw/upload/job_summary/%'] = array(
      'page callback' => 'rawpheno_upload_job_progress_json',
      'page arguments' => array(4),
      'access arguments' => array('access content'),
      'type' => MENU_CALLBACK,
    );

  // BACKUP
  // A page for uploading spreadsheet.
  $items['phenotypes/raw/backup'] = array(
    'title' => 'Backup',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('rawpheno_backup'),
    'access arguments' => array('access rawpheno'),
	  'file' => 'include/rawpheno.backup.form.inc',
    'type' => MENU_NORMAL_ITEM,
    'weight' => 7,
  );
    // List traits available in a project.
    $items['phenotypes/raw/backup/%/%/%'] = array(
      'title' => 'Backup',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('rawpheno_backup', 3, 4, 5),
      'access arguments' => array('access rawpheno'),
      'file' => 'include/rawpheno.backup.form.inc',
      'type' => MENU_CALLBACK,
    );

  // ADMININSTRATIVE PAGE OF THIS MODULE
  // A page for changing page colour and page title.
  $items['admin/tripal/extension/rawphenotypes'] = array(
    'title' => 'Rawphenotypes',
    'description' => 'Provides an interface for managing projects, users and column headers used in Rawphenotypes',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('rawpheno_admin_main_page'),
    'access arguments' => array('access administration pages'),
    'file' => 'include/rawpheno.admin.form.inc',
    'type' => MENU_NORMAL_ITEM,
  );

  $items['admin/tripal/extension/rawphenotypes/rawpheno_config'] = array(
    'title' => 'Page Configurations',
    'description' => 'Apply a colour scheme and set page title.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('rawpheno_admin_page'),
    'access arguments' => array('access administration pages'),
    'file' => 'include/rawpheno.admin.form.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 1,
  );

  // A page for managing R Transformation rules.
  $items['admin/tripal/extension/rawphenotypes/rawpheno_rheaders'] = array(
    'title' => 'Define R Transformation Rules',
    'description' => 'Define R Transfomation Rules to be applied when generating R Friendly alternative of column header.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('rawpheno_admin_rheaders'),
    'access arguments' => array('access administration pages'),
    'file' => 'include/rawpheno.admin.form.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 2,
  );

  // A page for managing project and traits.
  // List all projects and count traits available.
  $items['admin/tripal/extension/rawphenotypes/all_projects'] = array(
    'title' => 'Manage Projects',
    'description' => 'Create project, define column headers and appoint users to project.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('rawpheno_admin_all_projects'),
    'access arguments' => array('access administration pages'),
    'file' => 'include/rawpheno.admin.form.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 3,
  );
    // Edit trait in a project.
    $items['admin/tripal/extension/rawphenotypes/all_projects/%/%/%'] = array(
      'page callback' => 'drupal_get_form',
      'page arguments' => array('rawpheno_admin_project_management', 5, 6, 7),
      'access arguments' => array('access administration pages'),
      'file' => 'include/rawpheno.admin.form.inc',
      'type' => MENU_CALLBACK,
    );

  // Menu callback used to search user when appointing the user to a project.
  $items['admin/tripal/extension/rawphenotypes/username/%'] = array(
    'page callback' => 'rawpheno_manageproject_autocomplete_search',
    'page arguments' => array(5),
    'access arguments' => array('access administration pages'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}


/**
 * Implements hook_permission().
 */
function rawpheno_permission() {
  return array(
    'access rawpheno' => array(
      'title' => t('Access Raw Phenotypic pages (Instructions, Upload, Backup and Summary page'),
    ),

    'download rawpheno' => array(
      'title' => t('Download Phenotypic Data (CSV format) in Rawpheno Download Data page'),
    )
  );
}


/**
 * Implements hook_preprocess_HOOK().
 */
// Rawdata page.
function rawpheno_preprocess_rawpheno_rawdata(&$variables, $hook) {
  // Colour scheme, project check and data check.
  $rawpheno_load = rawpheno_module_defaults();
  list($variables['theme_colour'], $variables['my_projects'], $variables['has_prj'], $variables['has_data']) = $rawpheno_load;

  // Cross-link rawdata page to download page.
  $variables['rel_url'] = url('phenotypes/raw/download');
  // Page Title
  $variables['page_title'] = variable_get('rawpheno_rawdata_title');
  // D3 version
  $ver = rawpheno_function_d3_version();
  $ver = explode('.', $ver);
  // Version
  $variables['d3ver'] = (isset($ver[0])) ? trim($ver[0]) : 0;
  // Release
  $variables['d3rel'] = (isset($ver[1])) ? trim($ver[1]) : 0;

  // Does D3 exists
  $variables['d3_in'] = libraries_load('d3js');
}

// Instruction page.
function rawpheno_preprocess_rawpheno_instructions(&$variables, $hook) {
  // Colour scheme, project check and data check.
  $rawpheno_load = rawpheno_module_defaults();
  list($variables['theme_colour'], $variables['my_projects'], $variables['has_prj'], $variables['has_data']) = $rawpheno_load;

  // Cross-link instructions page to upload page.
  $variables['rel_url'] = url('phenotypes/raw/upload');
  // Page Title
  $variables['page_title'] = variable_get('rawpheno_instructions_title');

  // Path to module used to embed image in appendix tab.
  $variables['path'] = drupal_get_path('module', 'rawpheno');

  // Spreadsheet writer is in?
  $is_in = libraries_get_path('PHP_XLSXWriter_plus');
  $variables['writer_in'] = $is_in;
}

// Upload page.
function rawpheno_preprocess_rawpheno_upload_form_master(&$variables, $hook) {
  // Colour scheme, project check and data check.
  $rawpheno_load = rawpheno_module_defaults();
  list($variables['theme_colour'], $variables['my_projects'], $variables['has_prj'], $variables['has_data']) = $rawpheno_load;

  // Directory permission used in upload and backup.
  $pub_dir = 'public://';

  $perm = file_prepare_directory($pub_dir);
  $variables['dir_permission'] = $perm;

  // Does drag and drop module exist?
  $is_in = module_exists('dragndrop_upload_element');
  $variables['dnd_in'] = $is_in;

  // Does spreadsheet reader exist?
  $is_in = libraries_get_path('spreadsheet-reader');
  $variables['reader_in'] = $is_in;

  // Cross-link upload page to instructions page.
  $variables['rel_url'] = url('phenotypes/raw/instructions');
  // Page Title
  $variables['page_title'] = variable_get('rawpheno_upload_title');

  // Needs url in help window and links in stage 3.
  $variables['page_url'] =
    array(
      'rawpheno_rawdata'      => url('phenotypes/raw'),
      'rawpheno_download'     => url('phenotypes/raw/download'),
      'rawpheno_instructions' => url('phenotypes/raw/instructions'),
      'rawpheno_upload'       => url('phenotypes/raw/upload'),
      'rawpheno_backup'       => url('phenotypes/raw/backup')
    );

  // Stages in upload page.
  $variables['upload_stages'] = array('check'  => 'Validate Spreadsheet',
                                      'review' => 'Describe New Trait',
                                      'save'   => 'Save Spreadsheet');
}

// Backup page.
function rawpheno_preprocess_rawpheno_backup(&$variables, $hook) {
  // Colour scheme, project check and data check.
  $rawpheno_load = rawpheno_module_defaults();
  list($variables['theme_colour'], $variables['my_projects'], $variables['has_prj'], $variables['has_data']) = $rawpheno_load;

  // Directory permission used in upload and backup.
  $pub_dir = 'public://';

  $perm = file_prepare_directory($pub_dir);
  $variables['dir_permission'] = $perm;

  // Does drag and drop module exist?
  $is_in = module_exists('dragndrop_upload_element');
  $variables['dnd_in'] = $is_in;

  // Does spreadsheet reader exist?
  $is_in = libraries_get_path('spreadsheet-reader');
  $variables['reader_in'] = $is_in;

  // Cross-link backup page to instructions page.
  $variables['rel_url'] = url('phenotypes/raw/instructions');
  // Page Title
  $variables['page_title'] = variable_get('rawpheno_backup_title');
}

// Download page.
function rawpheno_preprocess_rawpheno_download(&$variables, $hook) {
  // Colour scheme, project check and data check.
  $rawpheno_load = rawpheno_module_defaults();
  list($variables['theme_colour'], $variables['my_projects'], $variables['has_prj'], $variables['has_data']) = $rawpheno_load;

  // Cross-link download page to download page.
  $variables['rel_url'] = url('phenotypes/raw');
  // Page Title
  $variables['page_title'] = variable_get('rawpheno_download_title');
}

// Load module colour scheme, check if user has project and check if module has data.
function rawpheno_module_defaults() {
  // Colour scheme selected by the user from the admin/configuration.
  $colour = variable_get('rawpheno_colour_scheme');
  // This colour will fill background of header and top right button, and border of content area.
  $colour = (empty($colour)) ? '#304356' : $colour;

  // Projects assigned to user.
  $log_user = $GLOBALS['user']->uid;
  $my_projects = rawpheno_function_user_project($log_user);

  // Does the module contain project?
  $has_project = rawpheno_function_project();

  // If it has project, does it have data?
  $has_data = rawpheno_function_data();

  return array(
    $colour,      // Colour scheme.
    $my_projects, // User appointed project.
    $has_project, // Module has at least a project.
    $has_data,    // Module has data.
  );
}


/**
 * Implements hook_theme().
 *
 * Returns HTML for rawpheno pages.
 */
function rawpheno_theme($existing, $type, $theme, $path) {
  // Rawdata page.
  $items['rawpheno_rawdata'] = array(
    'render element' => 'form',
    'template' => 'rawpheno_pages',
    'path' => $path . '/theme',
  );

  // Instructions page.
  $items['rawpheno_instructions'] = array(
    'render element' => 'form',
    'template' => 'rawpheno_pages',
    'path' => $path . '/theme',
  );

  // Download page.
  $items['rawpheno_download'] = array(
    'render element' => 'form',
    'template' => 'rawpheno_pages',
    'path' => $path . '/theme',
  );

  // Backup page.
  $items['rawpheno_backup'] = array(
    'render element' => 'form',
    'template' => 'rawpheno_pages',
    'path' => $path . '/theme',
  );

  // Upload page.
  $items['rawpheno_upload_form_master'] = array(
    'render element' => 'form',
    'template' => 'rawpheno_pages',
    'path' => $path . '/theme',
  );
    // Upload Errors.
    $items['rawpheno_upload_validation_report'] = array(
      'template' => 'rawpheno_upload_validation_report',
      'path' => $path . '/theme',
    );

  return $items;
}


/**
 * Implements hook_libraries_info().
 *
 * Define external libraries: Spreadsheet Reader and D3JS
 */
function rawpheno_libraries_info() {
  // Spreadsheet reader
  // File option is empty since library files are included
  // individually using include_once().
  // files in: sites/all/libraries/spreadsheet-reader
  //   - SpreadsheetReader.php
  //   - SpreadsheetReaderXLSX.php
  //   - SpreadsheetReaderXLS.php
  //   - php-excel-reader/excel_reader2.php

  // NOTE: To prevent library form auto formatting data to MM/DD/YYYY,
  //       suggest a new data format YYYY-mm-dd in the source code in line:
  //       * line 678 in excel_reader2.php
  //           0xe = "m/d/Y to 0xe => "Y-m-d"
  //       * line 834 in SpreadsheetReader_XLSX.php
  //           $Value = $Value -> format($Format['Code']); to $Value = $Value -> format('Y-m-d');

  // Let Drupal decide where library is.
  $lib_reader = libraries_get_path('spreadsheet-reader');

  $libraries['spreadsheet_reader'] = array(
    'name' => 'NUOVO Spreadsheet',
    'vendor url' => 'https://github.com/nuovo/spreadsheet-reader',
    'version callback' => 'rawpheno_function_reader_version_callback',
    'download url' => 'https://github.com/nuovo/spreadsheet-reader/archive/master.zip',
    'library path' => $lib_reader,
    'path' => $lib_reader . '/',
    'files' => array(),
  );

  // Spreadsheet writer.
  // Let Drupal decide where library is.
  $lib_writer = libraries_get_path('PHP_XLSXWriter_plus');

  $libraries['spreadsheet_writer'] = array(
    'name' => 'PHP_XLSXWriter_plus Spreadsheet Writer',
    'vendor url' => 'https://github.com/SystemDevil/PHP_XLSXWriter_plus',
    'version' => 1,
    'download url' => 'https://github.com/SystemDevil/PHP_XLSXWriter_plus/archive/master.zip',
    'library path' => $lib_writer,
    'files' => array('xlsxwriter.class.php'),
  );

  // D3 JavaScript.
  // Let Drupal decide where library is
  $lib_d3 = libraries_get_path('d3');

  $libraries['d3js'] = array(
    'name' => 'D3 Data-Driven Documents',
    'vendor url' => 'https://d3js.org/',
    'version callback' => 'rawpheno_function_d3_version_callback',
    'download url' => 'https://github.com/d3/d3/releases/download/v3.5.14/d3.zip',
    'library path' => $lib_d3,
    'files' => array(
      'js' => array('d3.js')
    ),
  );

  return $libraries;
}


/**
 * Function callback: return the version of the spreadsheet reader library installed.
 *
 * @see implementation of hook_libraries_info().
 */
function rawpheno_function_reader_version_callback() {
 $ver = rawpheno_function_sreader_version();

 return $ver;
}

/**
 * Function callback: return the version of the d3 library installed.
 *
 * @see implementation of hook_libraries_info().
 */
function rawpheno_function_d3_version_callback() {
 $ver = rawpheno_function_d3_version();

 return $ver;
}


/**
 * Function callback: used by autcomplete search functionality
 * used in manage project page - appoint a user to the project.
 */
function rawpheno_manageproject_autocomplete_search($project_id, $key = '') {
  // Array to hold all user.
  $arr_user = array();

  $sql = "SELECT name, mail FROM {users}
          WHERE
            status = 1
            AND LOWER(name) LIKE :name
          ORDER BY name DESC LIMIT 10";

  $args = array(':name' => '%' . strtolower($key) . '%');
  $user = db_query($sql, $args);

  foreach($user as $u) {
     $arr_user[$u->name] = $u->name . ' - ' . $u->mail;
  }

   drupal_json_output($arr_user);
 }

/**
 * Function callback: Generate Tripal Job progress JSON.
 *
 * @param $job_id
 *   An integer containing the job id number of the job process to monitor.
 *
 * @retun
 *   A JSON and containing progress and status of job object.
 */
function rawpheno_upload_job_progress_json($job_id) {
  // This is important as field requires the job id to be numeric value.
  $job_id = (int)$job_id;
  // Get the Tripal Job Object.
  $job = tripal_get_job($job_id);

  // Test if the Tripal Job exists and is that the status is not completed.
  if ($job) {
    if(trim(strtolower($job->status)) != 'completed') {
      // Read the file containing the upload file progress of the Tripal Job.
      // Please see rawpheno.upload.excel.inc - line: 69.
      $tmp = file_directory_temp();
      $filename = $tmp . '/' . 'job-progress' . $job_id . '.txt';
      $percent = file_get_contents($filename);

      // In the event of file collision or file writing process and file read returns nothing
      // show ... (indicate calculating) instead. This will correct itself the next file read.
      $percent_completed = empty($percent) ? '...' : $percent;
      $message = ($percent == 100 OR trim(strtolower($job->status)) == 'completed')
        ? 'Completed'
        : $job->status;
    }
    else {
      $percent_completed = 100;
      $message = $job->status;

      if ($job->progress != 100) {
        // Update Drupal Jobs Table when 100 percent only. This is to ensure that
        // the progress wont get non numeric value when file read returns nothing
        // usually happens when read and write not in sync.
        db_update('tripal_jobs')
          ->fields(array('progress' => (int)$progress['percentage']))
          ->condition('job_id', $job_id, '=')
          ->execute();
      }
    }

    // This is the exact format expected by the progress bar so do not alter it.
    $progress = array(
      'percentage' => $percent_completed,
      'message' => $message,
    );

    // Print the array as JSON to the screen.
    print drupal_json_output($progress);

    // Do not show the Drupal headers and formatting.
    // This is critical as if anything else is printed to the screen you will see
    // an AJAX error instead of your progress bar ;-).
    exit();
  }
}



/**
 * Function callback: Autocomplete search field.
 *
 * @see hook_menu()
 *
 * @param $key
 *   A string containing the search keywords entered in the search field.
 * @param $project_id
 *   An integer containing the project id number.
 *
 * @return
 *   A JSON where each trait is both the key and the value. The key is what is
 *   sent to JavaScript processing the search, while the value is what is suggested
 *   to user while typing in the seach field.
 */
function rawpheno_instructions_autocomplete_search($project_id, $key = '') {
  $trait_type = rawpheno_function_trait_types();

  $sql = "SELECT name
          FROM {cvterm} RIGHT JOIN pheno_project_cvterm USING(cvterm_id)
          WHERE project_id = :project_id AND type <> :plantprop";

  $args = array(':project_id' => $project_id, ':plantprop' => $trait_type['type4']);
  $m = chado_query($sql, $args);

  // Array to hold list of traits.
  $arr_headers = array();

  // Determine if keyword is provided.
  if (empty($key)) {
    foreach($m as $n) {
      $arr_headers[] = $n->name;
    }
  }
  else {
    foreach($m as $n) {
      if (stristr($n->name, $key)) {
        $arr_headers[$n->name] = $n->name;
      }
    }
  }

  drupal_json_output($arr_headers);
}


/**
 * Function callback: Generate data for the heat map.
 *
 * @see hook_menu()
 *
 * @return
 *   A JSON and each member has the following objects:
 *   location, year, rep, # traits, list of traits with value.
 */
function rawpheno_rawdata_summary_json() {
  // Ensure project id is valid.
  // Must exists, must not be empty and must not be more that 10 chars/digits.
  if (!isset($_GET['p']) OR empty($_GET['p']) OR strlen($_GET['p']) >= 10) {
    // No data.
    return 0;
  }
  else {
    // Get data for this project.
    $project_id = (int)trim(strip_tags($_GET['p']));

    // Get trait id of planting data.
    $planting_date = rawpheno_get_trait_id('Planting Date (date)');
    // get trait id of # of seeds planted
    $seeds_planted = rawpheno_get_trait_id('# of Seeds Planted (count)');

    // Minimum rep per year per location.
    $min_set = 3;
    // Select all location present in the materialized view.
    $sql_location = "SELECT DISTINCT location
                     FROM chado.rawpheno_rawdata_mview INNER JOIN {pheno_plant_project} USING(plant_id)
                     WHERE project_id = :project
                     ORDER BY location ASC";

    $result_location = db_query($sql_location, array(':project' => (int)$project_id));
    $count_location = $result_location->rowCount();

    if ($count_location > 0) {
      // Array to hold data.
      $data_json = array();
      // Array to hold planting years and rep.
      $arr_range['year'] = array();
      $arr_range['rep'] = array();

      // Define range of planting years and rep.
      for($i = 0; $i < 2; $i++) {
        $range = ($i == 0) ? 'year' : 'rep';
        // Query materialized view.
        $sql_range = sprintf("
          SELECT DISTINCT %s AS data_range FROM chado.rawpheno_rawdata_mview
          WHERE plant_id IN (SELECT plant_id FROM {pheno_plant_project} WHERE project_id = :project_id)
          ORDER BY data_range ASC", ($range == 'year') ? 'SUBSTRING(planting_date, 1, 4)' : 'rep');

        $r = db_query($sql_range, array(':project_id' => $project_id));
        $count_data = $r->rowCount();

        // Determine if total number of years is less than minimum number.
        if ($count_data < $min_set) {
          // Year/rep count is less than minimum, fill the gap to make the
          // number always to minimum.

          // Initial/starting year/rep.
          $start_value = $r->fetchField();
          $arr_range[$range][] = $start_value;

          // Fill the missing years/rep and push to array.
          for($c = 1; $c < $min_set; $c++) {
            // Next year in the SQL result.
            $d = $r->fetchField();
            if (empty($d)) {
              // If it is empty, compute the next year.
              $start_value += 1;
              $arr_range[$range][] = $start_value;
            }
            else {
              // Year is present, store and set the start value to this year.
              $arr_range[$range][] = $d;
              $start_value = $d;
            }
          }
        }
        else {
          // There is more than the minimum year/rep returned by the query.
          // Store all values to years/rep array.
          foreach($r as $range_value) {
            $arr_range[$range][] = $range_value->data_range;
          }
        }
      }

      // Construct data set.
      // Read each location available and construct data set.
      $sql = "SELECT ARRAY_TO_STRING(ARRAY_AGG(DISTINCT all_traits), ',') AS all_traits
              FROM chado.rawpheno_rawdata_mview
              WHERE
                location = :location
                AND SUBSTRING(planting_date, 1, 4) = :year
                AND rep = :rep
                AND plant_id IN
                  (SELECT plant_id FROM {pheno_plant_project} WHERE project_id = :project_id)
              LIMIT 1";

      while($data = $result_location->fetchAssoc()) {
        // In each location, read each planting year.
        foreach($arr_range['year'] as $year) {
          // In each year, read each rep.
          foreach($arr_range['rep'] as $rep) {
            // Each location in the materialized view
            $location = $data['location'];

            $args = array(':year' => $year, ':rep' => $rep, ':location' => $location, ':project_id' => $project_id);
            // Get the entry with the most traits for this particular location, year and rep.
            $traits = db_query($sql, $args)
              ->fetchObject();

            if (!empty($traits->all_traits)) {
              $trait_list = explode(',', $traits->all_traits);
              $trait_list = array_unique($trait_list);

              // NOTE:
              // Less 2 to exclude trait Planting Data (date) and # of Seeds Planted (count).
              // Before doing that, test if these two traits were part of the traits the count is based on.
              $less = 0;
              if (in_array($planting_date, $trait_list)) {
                $less++;
              }

              if (in_array($seeds_planted, $trait_list)) {
                $less++;
              }

              $trait_count = ((count($trait_list) - $less) < 0) ? 0 : (count($trait_list) - $less);
              $trait_list = implode(',', $trait_list);
            }
            else {
              $trait_list = 0;
              $trait_count = 0;
            }

            // Create a json entry with the following keys:
            // location, year, rep and trait.
            $arr_json[] = array('location' => $location,
                                'year' => $year,
                                'rep' => $rep,
                                'trait' => $trait_count,
                                'type_id' => $trait_list);
          }
        }
      }

      return $arr_json;
    }
    else {
      // No data.
      return 0;
    }
  }
}


/**
 * Function callback: Generate year and location used in categorizing barchart.
 *
 * @see hook_menu()
 *
 * @return
 *   A JSON containing the location and year for a given trait.
 */
function rawpheno_rawdata_trait_category_json() {
  if ((!isset($_GET['p']) OR strlen($_GET['p']) >= 10) OR
      (!isset($_GET['t']) OR strlen($_GET['t']) >= 10)) {

    // No data.
    return 0;
  }
  else {
    $project_id = trim(strip_tags($_GET['p']));
    $trait_id = trim(strip_tags($_GET['t']));

    // Location and planting_year (as Year).
    $category = array('location', 'planting_date');
    $arr_json = array();

    foreach($category as $c) {
      $col = ($c == 'location') ? 'location' : 'SUBSTRING(planting_date, 1, 4)';

      $sql = sprintf("
        SELECT DISTINCT %s AS col
        FROM {rawpheno_rawdata_mview} WHERE plant_id IN (SELECT plant_id FROM pheno_plant_project WHERE project_id = :project_id)
        AND STRPOS(all_traits, :trait_id) > 0
        ORDER BY col ASC", $col);

      $args = array(':project_id' => $project_id, ':trait_id' => $trait_id);
      $r = chado_query($sql, $args);

      foreach($r as $d) {
        $arr_json[$c][] = $d->col;
      }
    }
  }

  return $arr_json;
}


/**
 * Function callback: Generate data for the bar chart.
 *
 * @see hook_menu()
 *
 * @return
 *   A JSON containing the bins and data.
 *   bins is a list of computed bins and each data
 *   has location and bin objects.
 *
 * NOTE: The following column headers are excluded from the traits that can be visualized.
 *   Planting Date (date)
 *   Disease-specific Comments (text)
 *   Comments (text)
 *   # of Seeds Planted (count)
 */
function rawpheno_rawdata_trait_json() {
  // When the type of data is txt, we need to ensure that it not sooo long that it will break the chart.
  // To ensure that, we use this variable to check if the length is less or more and respond accordingly.
  $max_data_length = 10;

  // Types of data.
  $txt_type = 'txt';
  $int_type = 'int';
  $scale_type = 'scale';
  $ynunsure_type = 'y/n/?';

  // Valid categorize options.
  $arr_valid_category = array('location', 'year');

  // Ensure project id and trait id are valid.
  // Must exists, must not be empty and must not be more that 10 chars/digits.
  // 10 Digits more will throw a PSQL ERROR.
  if ((!isset($_GET['p']) OR empty($_GET['p']) OR strlen($_GET['p']) >= 10) OR
      (!isset($_GET['t']) OR empty($_GET['t']) OR strlen($_GET['t']) >= 10) OR
      (!isset($_GET['o']) OR empty($_GET['o']) OR strlen($_GET['o']) >= 20) OR
      (!isset($_GET['c']) OR empty($_GET['c']) OR !in_array($_GET['c'], $arr_valid_category))) {

    // No data.
    return 0;
  }
  else {
    $project_id = (int)trim(strip_tags($_GET['p']));
    $trait_id   = (int)trim(strip_tags($_GET['t']));

    // Get cvterm.
    $cvterm = tripal_get_cvterm(array('cvterm_id' => $trait_id, 'cv_id' => array('name' => 'phenotype_measurement_types')));
    if (!$cvterm) {
      return 0;
    }

    // Query unique values in in the column, get data type and char length of each unique entry.
    // CASE 1 - predict the data type of the value.
    // CASE 2 - determine the lenght of the value.
    $sql = "SELECT
              value AS data,
              CHAR_LENGTH(value) AS data_length
            FROM {pheno_measurements}
            WHERE type_id =
              (SELECT cvterm_id FROM {pheno_project_cvterm} WHERE project_id = :project_id AND cvterm_id = :cvterm_id LIMIT 1)
              AND plant_id IN (SELECT plant_id FROM pheno_plant_project WHERE project_id = :project_id)
            GROUP BY value ORDER BY value ASC";

    $args = array(':project_id' => $project_id, ':cvterm_id' => $trait_id);
    $d = db_query($sql, $args);

    // Array to hold the data_type.
    $arr_data_type = array();
    // Array to hold the length of data.
    $arr_data_length = array();
    // Array to hold the data.
    $arr_data = array();

    foreach($d as $m) {
      $dtype = (is_numeric($m->data)) ? 'int' : 'txt';
      $arr_data_type[] = $dtype;

      $arr_data_length[] = $m->data_length;
      $arr_data[] = $m->data;
    }

    // Get the overall data type.
    $data_type = array_unique($arr_data_type);

    if (count($data_type) > 1 OR $d->rowCount() <= 0) {
      // When there are too many data types or no data at all, do not visualize it.
      return 0;
    }
    else {
      $category = trim(strip_tags($_GET['c']));
      $option   = trim(strip_tags($_GET['o']));

      // Pass the values in categorize barchart.
      $arr_category = array(
        'category' => $category,
        'option'   => $option
      );

      // Else, chart it, but before doing so, determine if text or integer type.
      if ($data_type[0] == $int_type) {
        // Interger data type.
        $type = (rawpheno_function_unit($cvterm->name) == $scale_type) ? $scale_type : $int_type;
        return rawpheno_function_create_json($project_id, $trait_id, $type, $arr_category);
      }
      elseif ($data_type[0] == $txt_type) {
        // Text data type, but, if the length of data is sooo long, don't chart it.
        if (max($arr_data_length) > $max_data_length) {
          // Too long.
          return 0;
        }
        else {
          // Yes, chart it!
          $type = (rawpheno_function_unit($cvterm->name) == $ynunsure_type) ? $ynunsure_type : $txt_type;
          return rawpheno_function_create_json($project_id, $trait_id, $type, $arr_category, $arr_data);
        }
      }
    }
  }
}


// TRIPAL DOWNLOAD API IMPLEMENTATION (Function Callback).
/**
 *  Implements hook_register_trpdownload_type().
 */
function rawpheno_register_trpdownload_type() {
  $types = array();

  // The key is the machine name of my download type.
  $types['rawpheno_csv'] = array(
    // A human readable name to show in an administrative interface one day.
    'type_name' => 'Raw Phenotypes CSV',
    // A human readable description of the format.
    'format' => 'Comma-separated Values',
    // An array of functions that the API will use to customize your experience.
    'functions' => array(
      // The function that tripal jobs will call to generate the file.
      'generate_file' => 'rawpheno_trpdownload_generate_file',
      // OPTIONAL: provide a summary to the user on the download page.
      'summarize' => 'rawpheno_trpdownload_summarize_download',
      // OPTIONAL: determine your own filename.
      'get_filename' => 'rawpheno_trpdownload_get_filename',
      // OPTIONAL: Change the file suffix (defaults to .txt)
      'get_file_suffix' => 'rawpheno_trpdownload_get_suffix',
      // OPTIONAL: determine the human-readable format based on a function.
      'get_format' => 'rawpheno_trpdownload_get_readable_format',
    ),
  );

  return $types;
}

/**
 * Generate a file summary.
 */
function rawpheno_trpdownload_summarize_download($vars) {
  // Path to module.
  $path = drupal_get_path('module', 'rawpheno') . '/theme/';
  // Style nav links.
  $style = 'float: left; padding: 20px 0 0 0; height: 50px; font-size: 1em; margin: 0 2.5%; text-align:center; width: 20%; color: #118324 !important';
  // Style span element.
  $style2 = 'background-color: #FFFFFF; display: block; margin-top: 24px; padding: 5px 0;';

  // Div container to hold summary of options selected by user.
  $summary = '';

  // PROJECTS:
  $q = trim(implode('', $vars['download_args']['q']));
  $q = base64_decode($q);
  list($project, $location, $traits, $r_version) = explode('&', $q);

  $tmp = trim(str_replace('p=', '', $project));
  $project = explode(',', $tmp);

  $sql = "SELECT name FROM {project} WHERE project_id IN (:project)";
  $args = array(':project' => $project);
  $p = chado_query($sql, $args)
    ->fetchAllKeyed(0,0);
  $summary .= '<li> ' . count($p) . ' PROJECTS: <br /><em>' . implode(', ', $p) . '</em></li>';

  // LOCATIONS:
  $location = trim(str_replace('l=', '', $location));

  if ($location == '0') {
    // Load all locations available.
    $sql = "SELECT DISTINCT value AS location
            FROM pheno_plantprop
            WHERE type_id = (SELECT cvterm_id FROM {cvterm} WHERE name = 'Location' LIMIT 1)
            ORDER BY value ASC";
    $location = chado_query($sql)
      ->fetchCol(0);
  }
  else {
    $location = explode(',', $location);
  }
  $summary .= '<li> ' . count($location) . ' LOCATIONS: <br /><em>' . implode(', ', $location) . '</em></li>';

  // TRAITS:
  $traits = trim(str_replace('t=', '', $traits));

  if ($traits == 0) {
    // Load all traits available.
    $t = rawpheno_download_load_traits($location, $project);
    $traits = array_keys($t);
  }
  else {
    $traits = explode(',', $traits);
  }

  $sql = "SELECT name FROM {cvterm} WHERE cvterm_id IN (:cvterm_id)";
  $args = array(':cvterm_id' => $traits);
  $t = chado_query($sql, $args)
    ->fetchAllKeyed(0,0);
  $summary .= '<li> ' . count($t) . ' TRAITS: <br /><em>' . implode(', ', $t) . '</em></li>';

  // RVERSION:
  $r_version = trim(str_replace('r=', '', $r_version));

  $r_ver = ($r_version == 1) ? 'Yes' : 'No';
  $summary .= '<li>R FRIENDLY: <br /><em>' . $r_ver . '</em></li>';

  $output = '<div style="overflow-y: scroll; height: 60px; border: 1px solid #EAEAEA; padding: 5px 20px; background-color: #FFFFFF">' . $summary . '</div>';

  // Div container to hold navigation links to rawphenotypes page.
  $output .= '<div style="position: absolute; margin-top: 30px; display: inline-block; left: 12%; width: 70%; text-align: center;">
    <div class="container-buttons" style="padding: 30px 0 0 0; margin: 30px 0 0 0;text-align: center; width: 100%;">
      <div class="buttons-wrapper" style=" display: inline-block; margin: 0 auto; width: 90%;">
        <a href="../upload" target="_blank" style="background: url(../../../' . $path . 'img/icon-upload.gif) no-repeat center top;' . $style . '"><span style="' . $style2 . '">Upload New Data</span></a>
        <a href="../download" target="_blank" style="background: url(../../../' . $path . 'img/icon-download.gif) no-repeat center top;' . $style . '"><span style="' . $style2 . '">Download Data</span></a>
        <a href="../" target="_blank" style="background: url(../../../' . $path . 'img/icon-rawdata.gif) no-repeat center top;' . $style . '"><span style="' . $style2 . '">Data Summary</span></a>
        <a href="../instructions" target="_blank" style="background: url(../../../' . $path . 'img/icon-instructions.gif) no-repeat center top;' . $style . '"><span style="' . $style2 . '">Standard Procedure</span></a>
        <div class="clear-float"></div>
      </div>
    </div></div>';

  return $output;
}


/**
 * Generate a readable and unique filename for the file to be generated.
 */
function rawpheno_trpdownload_get_filename($vars) {
  $filename = 'rawpheno_csv' . date('YMd') .'_'. time();
  return $filename;
}


/**
 * Determine the file suffix for the file to be generated.
 */
function rawpheno_trpdownload_get_suffix($vars) {
  return 'csv';
}


/**
 * Function callback: generate csv file.
 */
function rawpheno_trpdownload_generate_file($variables, $job_id = NULL) {
  // Get query string and filename.
  $code = '';
  foreach($variables as $l => $v) {
    if(is_array($v)) {
      foreach($v as $j => $m) {
        if ($j == 'code') {
          $code = $m;
        }
      }
    }

    if ($l == 'filename') {
      $filename = $v;
    }
  }

  $q = base64_decode($code);
  list($project, $location, $traits, $r_version) = explode('&', $q);

  // Projects:
  $tmp = trim(str_replace('p=', '', $project));
  $project = explode(',', $tmp);

  // Locations:
  $location = trim(str_replace('l=', '', $location));

  if ($location == '0') {
    // Load all locations available.
    $sql = "SELECT DISTINCT value AS location
            FROM pheno_plantprop
            WHERE type_id = (SELECT cvterm_id FROM {cvterm} WHERE name = 'Location' LIMIT 1)
            ORDER BY value ASC";
    $location = chado_query($sql)
      ->fetchCol(0);
  }
  else {
    $location = explode(',', $location);
  }

  // Traits
  $traits = trim(str_replace('t=', '', $traits));

  if ($traits == 0) {
    // Load all traits available.
    $t = rawpheno_download_load_traits($location, $project);
    $traits = array_keys($t);
  }
  else {
    $traits = explode(',', $traits);
  }

  // Rversion
  $r_version = trim(str_replace('r=', '', $r_version));

  // Add planting date and # of seeds planted to the list of traits.
  // But, before doing this, make sure that these two column headers
  // are part or the project in the first place.
  $arr_notso_trait = array('Planting Date (date)', '# of Seeds Planted (count)');
  foreach($arr_notso_trait as $nt) {
    $sql = "SELECT cvterm_id FROM {cvterm} RIGHT JOIN pheno_project_cvterm USING(cvterm_id)
            WHERE name = :cvterm AND project_id IN (:project_id) LIMIT 1";

    $n = chado_query($sql, array(':cvterm' => $nt, ':project_id' => $project));

    if ($n->rowCount() == 1) {
      $traits[] = $n->fetchField();
    }
  }

  // Sub-query to select plant_id given a location and project.
  // NOTE: leading and trailing spaces are required.
  $sub_sql = " (SELECT plant_id
                FROM {pheno_plantprop} INNER JOIN {pheno_plant_project} USING(plant_id)
                WHERE value IN (:location) AND project_id IN (:project)) ";

  // Query values required by sub query.
  $arr_q_string = array(':project' => $project, ':location' => $location, ':traits' => $traits);

  // First we need to get the header. This will allow us to ensure that the data
  // downloaded all matches up with the trait it is associated with. Furthermore,
  // it will allow us to handle missing data.
  $sql = "SELECT 'B' || t2.cvterm_id AS id, t2.name
          FROM {pheno_plantprop} t1 LEFT JOIN chado.cvterm t2 ON t2.cvterm_id = t1.type_id
          WHERE t1.plant_id IN" . $sub_sql . "

          UNION

          SELECT 'C' || t2.cvterm_id AS id, t2.name
          FROM {pheno_measurements} t1 LEFT JOIN chado.cvterm t2 ON t2.cvterm_id=t1.type_id
          WHERE t2.cvterm_id IN (:traits) AND t1.plant_id IN" . $sub_sql . "
          GROUP BY t2.cvterm_id, t2.definition";

  $result = db_query($sql, $arr_q_string);

  // Array to hold column headers.
  //Add Name/Stock name column headers array.
  $header = array('A0' => 'Name');

  foreach ($result as $r) {
    $def = $r->name;

    // Get the R Friendly version when user requests for it.
    if ($r_version == 1) {
      // Get the R compatible version.
      $id_no = (int)trim(str_replace(array('B', 'C'), '', $r->id));
      $rfreindly = rawpheno_download_r_compatible($id_no);

      // When no equivalent R version is available, load the definition instead.
      $def = ($rfreindly == null) ? $r->name : $rfreindly;
    }

    // Column headers array.
    $header[ $r->id ] = $def;
  }

  // Sort array by key.
  ksort($header);

  // Query to join data from different tables.
  // Result: plant_id, trait_id, definition, data, and a grouping string
  // The result is sorted by plant_id and the grouping string ensuring that the first
  // row is Name - containing the stock name.
  // The result will be sorted into standard order: plot,entry,name,rep,location,traits.....

  // Thus first we select the name. Note that  the tid is 0 because this doesn't have a cvterm (ie: not a trait).
  $sql = "SELECT t2.plant_id AS id, '0' AS tid, 'Name' AS def, t1.name AS value, 'A' AS grp
          FROM {chado.stock} AS t1 INNER JOIN {pheno_plant} AS t2 USING(stock_id)
          WHERE t2.plant_id IN" . $sub_sql

          // Then we add on the required information (ie: plot, entry, rep, location)
          . "UNION

          SELECT t1.plant_id AS id, t1.type_id AS tid, t2.name AS def, t1.value AS value, 'B' AS grp
          FROM {pheno_plantprop} AS t1
          INNER JOIN chado.cvterm AS t2 ON t1.type_id = t2.cvterm_id
          WHERE t1.plant_id IN" . $sub_sql

          // Finally we add in all the traits.
          . "UNION

          SELECT t1.plant_id AS id, t1.type_id as tid, t2.name AS def, ARRAY_TO_STRING(ARRAY_AGG(DISTINCT t1.value), '<m_value>') AS value, 'C' as grp
          FROM {pheno_measurements} AS t1
          INNER JOIN chado.cvterm AS t2 ON t1.type_id = t2.cvterm_id
          WHERE t2.cvterm_id IN (:traits) AND t1.plant_id IN" . $sub_sql

          // Lastly we order the results by plant_id and grouping string, and tid.
          . "GROUP BY t1.plant_id, t1.type_id, t2.name
             ORDER BY id, grp, tid ASC";

  $results = db_query($sql, $arr_q_string);

  if ($results) {
    $filepath = variable_get('trpdownload_fullpath', '') . $filename;
    drush_print("File: " . $filepath);
    $FILE = fopen($filepath, 'w') or die ('Uable to create file to write to');

    fputcsv($FILE, $header);

    // Build a multi-dimensional array with all the data in it. This array is keyed
    // 1st by plant_id and then by Group||cvterm_id (ie: B4243).
    // Note: this first array will not have any missing data cells filled in.
    $rows = array();
    foreach($results as $r) {
      $rows[ $r->id ][ $r->grp . $r->tid ] = $r->value;
    }

    // Total lines;
    $total_lines = count($rows);
    drush_print('Total Lines: ' . $total_lines);

    // Now we want to process each row to add entries for missing data.
    // We will do this by looping through the header for each row and if there isn't
    // already data set for that cell then we will add missing data.
    // Note: We will save the data to the file as we go.
    $cur_line = 0;
    foreach ($rows as $row) {
      $cur_line++;
      $percent = $cur_line/$total_lines * 100;
      if ($percent%5 == 0) {
        drush_print(round($percent,2).'% Complete.');
        db_query('UPDATE {tripal_jobs} SET progress=:percent WHERE job_id=:id',
          array(':percent' => round($percent), ':id' => $job_id));
      }

      // First, add missing data for each entry in the header that is not in the row.
      foreach ($header as $id => $title) {
        if (!isset($row[$id])) {
          $row[$id] = 'NA';
        }
        else {
          $l = explode('<m_value>', $row[$id]);

          if (count($l) >= 2) {
            $row[$id] = str_replace('<m_value>',',', $row[$id]);
            drush_print('Multiple values found: Line #' . ($cur_line + 1) . ' Col: ' . $title);
          }
        }
      }

      // Sort the row based on the keys to make sure they match with the header.
      ksort($row);

      // Write this row to the file as CSV.
      fputcsv($FILE, $row);
    }

     // Finally, close the file.
     fclose($FILE);
  }
}
